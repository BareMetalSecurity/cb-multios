//#include <unistd.h>
//#include <stdio.h>
//#include <stdlib.h>
//#include <errno.h>
#include <libcgc.h>
#include <stdlib.h>

#ifdef _WIN32
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#endif

#if 0
void _terminate(unsigned int status) __attribute__((__noreturn__));
int transmit(int fd, const void *buf, size_t count, size_t *tx_bytes);
int receive(int fd, void *buf, size_t count, size_t *rx_bytes);
int fdwait(int nfds, cgc_fd_set *readfds, cgc_fd_set *writefds,
	   const struct cgc_timeval *timeout, int *readyfds);
int allocate(size_t length, int is_X, void **addr);
int deallocate(void *addr, size_t length);
int random(void *buf, size_t count, size_t *rnd_bytes);
#endif

extern void exit(int status);
extern ssize_t write(int fildes, const void *buf, size_t nbyte);
extern ssize_t read(int fildes, void *buf, size_t nbyte);
extern ssize_t select(int nfds, cgc_fd_set *readfds, cgc_fd_set *writefds, cgc_fd_set *exceptfds, const struct cgc_timeval *timeout);

#ifndef _WIN32
extern void *mmap(void *addr, size_t len, int prot, int flags, int fildes, ssize_t off); 
extern int munmap(void *addr, size_t length);
#endif

extern void *memcpy(void *dest, const void *src, size_t n);
extern long int random(void);

#ifdef APPLE
    extern int errno;
#elif LINUX
    #include <errno.h>
#endif 
    
#define NULL 0
typedef struct {
        unsigned char   *_ptr;
        int     _cnt;
        unsigned char   *_base;
        unsigned char   *_bufendp;
        short   _flag;
        short   _file;
        int     __stdioid;
        char    *__newbase;
        long    _unused[1];
} FILE;


void _terminate(unsigned int status)
{
    exit(status);
}

int transmit(int fd, const void *buf, size_t count, size_t *tx_bytes)
{
    ssize_t num_written = 0;

    num_written = write(fd, buf, count);

    if (num_written < 0)
        return errno;

    if (tx_bytes)
        *tx_bytes = num_written;

    return 0;
}

int receive(int fd, void *buf, size_t count, size_t *rx_bytes)
{
    ssize_t num_read = 0;

    num_read = read(fd, buf, count);

    if (num_read < 0)
        return errno;

    if (rx_bytes)
        *rx_bytes = num_read;

    return 0;
}

int cgc_fdwait(int nfds, cgc_fd_set *readfds, cgc_fd_set *writefds, const struct cgc_timeval *timeout, int *readyfds)
{

    ssize_t num_fd = 0;
#ifdef WIN32
    // only single binary CBs, for now
    if (nfds > 3) {
        return -EINVAL;
    }

    HANDLE handles[3];
    handles[0] = GetStdHandle(STD_INPUT_HANDLE);
    handles[1] = GetStdHandle(STD_OUTPUT_HANDLE);
    handles[2] = GetStdHandle(STD_ERROR_HANDLE);

    DWORD msecs = timeout->tv_sec * 1000;
    msecs += timeout->tv_usec / 1000;


    DWORD which = WaitForMultipleObjects(nfds, handles, FALSE, msecs);

    switch(which) {
        case WAIT_FAILED:
        case WAIT_TIMEOUT:
        default:
            return GetLastError();
            break;
        case WAIT_OBJECT_0+0:
        case WAIT_OBJECT_0+1:
        case WAIT_OBJECT_0+2:
            *readyfds = which - WAIT_OBJECT_0; 
            break;
    }
#else

    num_fd = select(nfds, readfds, writefds, NULL, timeout);

    if (num_fd < 0)
        return errno;

    if (readyfds)
        *readyfds = num_fd;

#endif
    return 0;
}

int allocate(size_t length, int is_X, void **addr)
{
    void *mem_return = NULL;
    const int MAP_PRIVATE  =  0x0002;
    const int MAP_ANON     =  0x1000;

    const int PROT_READ    =  0x01;
    const int PROT_WRITE   =  0x02;
    const int PROT_EXEC    =  0x04;

    const void *MAP_FAILED = (void *)-1;

    #ifdef _WIN32
    unsigned int prot = PAGE_READWRITE;
    if (is_X)
        prot = PAGE_EXECUTE_READWRITE;
    #else
    unsigned int prot = PROT_READ | PROT_WRITE;
    if (is_X)
        prot |= PROT_EXEC;
    #endif


#ifdef _WIN32
    mem_return = VirtualAlloc(NULL, length, MEM_COMMIT | MEM_RESERVE, prot);
    if (mem_return == NULL)
        return GetLastError();
#else
    mem_return = mmap(NULL, length, prot, MAP_ANON | MAP_PRIVATE, 0, 0);
    if (mem_return == MAP_FAILED)
        return errno;
#endif
    *addr = mem_return;
    return 0;
}

int deallocate(void *addr, size_t length)
{

    ssize_t mun_return = 0;
    #ifdef _WIN32
    mun_return =  VirtualFree(addr, length, MEM_RELEASE);
    #else
    mun_return =  munmap( addr, length);
    #endif

    #ifdef _WIN32
    if (mun_return != 0) {
        return GetLastError();
    }
    #else
    if (mun_return < 0)
        return errno;
    #endif

    return 0;

}

int cgc_random(void *buf, size_t count, size_t *rnd_bytes)
{
    if (count == 0)
        return 0;
    if (count > SSIZE_MAX)
        return NULL; //??? unspecified

    #ifdef _WIN32
    // generated by dice roll, guaranteed to be random
    memset(buf, 42, count);
    *rnd_bytes = count;
    #else

    FILE * fp;
    int numRead;

    fp = fopen("/dev/urandom", "r");
    numRead = fread(buf, 1, count, fp);
    fclose(fp);

    if (numRead < count){
        return errno;
    }

    *rnd_bytes = numRead;
    #endif

    return 0;
}


void *cgc_memcpy(void *dest, const void *src, size_t n) {
    return memcpy(dest, src, n);
}

void *cgc_memset(void *dest, const int c, size_t n) {
    return memset(dest, c, n);
}


